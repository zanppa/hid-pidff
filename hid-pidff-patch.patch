--- hid-pidff.c.orig	2014-01-20 04:40:07.000000000 +0200
+++ hid-pidff.c	2014-03-09 23:08:08.917277299 +0200
@@ -2,6 +2,7 @@
  *  Force feedback driver for USB HID PID compliant devices
  *
  *  Copyright (c) 2005, 2006 Anssi Hannula <anssi.hannula@gmail.com>
+ *                2014 Lauri Peltonen <lauri.peltonen@gmail.com>
  */
 
 /*
@@ -20,7 +21,7 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  */
 
-/* #define DEBUG */
+#define DEBUG
 
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 
@@ -32,7 +33,15 @@
 
 #include "usbhid.h"
 
+#define IS_DEVICE_MANAGED(device) (test_bit(PID_SUPPORTS_DEVICE_MANAGED, \
+			&device->flags))
+#define IS_LAZY_INITIALIZED(device) (test_bit(PID_IS_LAZY_INITIALIZED, \
+			&device->flags))
+
 #define	PID_EFFECTS_MAX		64
+/* Only 2 axes are currently supported, some places support more,
+ * but in some places 2 is still a hard coded limit. */
+#define PID_AXES_MAX		2
 
 /* Report usage table used to put reports into an array */
 
@@ -40,67 +49,85 @@
 #define PID_EFFECT_OPERATION	1
 #define PID_DEVICE_GAIN		2
 #define PID_POOL		3
-#define PID_BLOCK_LOAD		4
-#define PID_BLOCK_FREE		5
-#define PID_DEVICE_CONTROL	6
+#define PID_DEVICE_CONTROL	4
+
+#define PID_BLOCK_LOAD		5
+#define PID_BLOCK_FREE		6
 #define PID_CREATE_NEW_EFFECT	7
 
-#define PID_REQUIRED_REPORTS	7
+#define PID_POOL_MOVE		8
 
-#define PID_SET_ENVELOPE	8
-#define PID_SET_CONDITION	9
-#define PID_SET_PERIODIC	10
-#define PID_SET_CONSTANT	11
-#define PID_SET_RAMP		12
+#define PID_SET_ENVELOPE	9
+#define PID_SET_CONDITION	10
+#define PID_SET_PERIODIC	11
+#define PID_SET_CONSTANT	12
+#define PID_SET_RAMP		13
+
+#define PID_REQUIRED_REPORTS		4
+#define PID_REQUIRED_DEVICE_MANAGED	7
+#define PID_REQUIRED_POOL_MOVE		8
 static const u8 pidff_reports[] = {
-	0x21, 0x77, 0x7d, 0x7f, 0x89, 0x90, 0x96, 0xab,
-	0x5a, 0x5f, 0x6e, 0x73, 0x74
+	0x21, 0x77, 0x7d, 0x7f, 0x96,	/* Required for all devices */
+	0x89, 0x90, 0xab,		/* Required for device managed */
+	0x85,				/* Required for defragmentation */
+	0x5a, 0x5f, 0x6e, 0x73, 0x74	/* Others */
 };
-
 /* device_control is really 0x95, but 0x96 specified as it is the usage of
 the only field in that report */
 
 /* Value usage tables used to put fields and values into arrays */
 
-#define PID_EFFECT_BLOCK_INDEX	0
+#define PID_EFFECT_BLOCK_INDEX		0
+#define PID_PARAM_BLOCK_OFFSET		0
 
-#define PID_DURATION		1
-#define PID_GAIN		2
-#define PID_TRIGGER_BUTTON	3
-#define PID_TRIGGER_REPEAT_INT	4
-#define PID_DIRECTION_ENABLE	5
-#define PID_START_DELAY		6
+#define PID_INDEX_PLACEHOLDER		0xff
+#define PID_EFFECT_BLOCK_INDEX_CODE	0x22
+#define PID_PARAM_BLOCK_OFFSET_CODE	0x23
+
+#define PID_DURATION			1
+#define PID_TRIGGER_BUTTON		2
+#define PID_TRIGGER_REPEAT_INT		3
+#define PID_DIRECTION_ENABLE		4
+#define PID_START_DELAY			5
 static const u8 pidff_set_effect[] = {
-	0x22, 0x50, 0x52, 0x53, 0x54, 0x56, 0xa7
+	0x22, 0x50, 0x53, 0x54, 0x56, 0xa7
 };
 
+#define PID_GAIN		0
+static const u8 pidff_set_effect_optional[] = {	0x52 };
+
 #define PID_ATTACK_LEVEL	1
 #define PID_ATTACK_TIME		2
 #define PID_FADE_LEVEL		3
 #define PID_FADE_TIME		4
-static const u8 pidff_set_envelope[] = { 0x22, 0x5b, 0x5c, 0x5d, 0x5e };
+static const u8 pidff_set_envelope[] = {
+	PID_INDEX_PLACEHOLDER, 0x5b, 0x5c, 0x5d, 0x5e
+};
+
 
-#define PID_PARAM_BLOCK_OFFSET	1
-#define PID_CP_OFFSET		2
-#define PID_POS_COEFFICIENT	3
-#define PID_NEG_COEFFICIENT	4
-#define PID_POS_SATURATION	5
-#define PID_NEG_SATURATION	6
-#define PID_DEAD_BAND		7
+#define PID_CP_OFFSET		1
+#define PID_POS_COEFFICIENT	2
+#define PID_NEG_COEFFICIENT	3
+#define PID_POS_SATURATION	4
+#define PID_NEG_SATURATION	5
+#define PID_DEAD_BAND		6
 static const u8 pidff_set_condition[] = {
-	0x22, 0x23, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65
+	PID_INDEX_PLACEHOLDER, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65
 };
 
-#define PID_MAGNITUDE		1
+#define PID_MAGNITUDE	1
 #define PID_OFFSET		2
 #define PID_PHASE		3
 #define PID_PERIOD		4
-static const u8 pidff_set_periodic[] = { 0x22, 0x70, 0x6f, 0x71, 0x72 };
-static const u8 pidff_set_constant[] = { 0x22, 0x70 };
+static const u8 pidff_set_periodic[] = {
+	PID_INDEX_PLACEHOLDER, 0x70, 0x6f, 0x71, 0x72
+};
+
+static const u8 pidff_set_constant[] = { PID_INDEX_PLACEHOLDER, 0x70 };
 
 #define PID_RAMP_START		1
 #define PID_RAMP_END		2
-static const u8 pidff_set_ramp[] = { 0x22, 0x75, 0x76 };
+static const u8 pidff_set_ramp[] = { PID_INDEX_PLACEHOLDER, 0x75, 0x76 };
 
 #define PID_RAM_POOL_AVAILABLE	1
 static const u8 pidff_block_load[] = { 0x22, 0xac };
@@ -113,10 +140,16 @@ static const u8 pidff_block_free[] = { 0
 #define PID_DEVICE_GAIN_FIELD	0
 static const u8 pidff_device_gain[] = { 0x7e };
 
-#define PID_RAM_POOL_SIZE	0
+#define PID_RAM_POOL_SIZE		0
 #define PID_SIMULTANEOUS_MAX	1
 #define PID_DEVICE_MANAGED_POOL	2
-static const u8 pidff_pool[] = { 0x80, 0x83, 0xa9 };
+#define PID_POOL_ALIGNMENT		3
+static const u8 pidff_pool[] = { 0x80, 0x83, 0xa9, 0x84 };
+
+#define PID_MOVE_SOURCE		0
+#define PID_MOVE_DESTINATION	1
+#define PID_MOVE_LENGTH			2
+static const u8 pidff_pool_move[] = { 0x86, 0x87, 0x88 };
 
 /* Special field key tables used to put special field keys into arrays */
 
@@ -148,17 +181,42 @@ static const u8 pidff_block_load_status[
 #define PID_EFFECT_STOP		1
 static const u8 pidff_effect_operation_status[] = { 0x79, 0x7b };
 
+/* Flags to indicate capabilities of the device */
+
+#define PID_SUPPORTS_DEVICE_MANAGED		1
+#define PID_SUPPORTS_POOL_MOVE			2
+#define PID_IS_LAZY_INITIALIZED			3
+
 struct pidff_usage {
 	struct hid_field *field;
 	s32 *value;
 };
 
+struct pidff_memory_block {
+	unsigned int block_index;	/* Effect block index */
+	unsigned int block_offset;	/* Effect block offset */
+	unsigned int size;		/* Block size (reserved memory) */
+	u8 offset_num;
+
+	struct pidff_memory_block *next;
+};
+
+struct pidff_info {
+	int id;
+	int effect_type_id;
+	struct pidff_memory_block *offset[PID_AXES_MAX];
+};
+
 struct pidff_device {
 	struct hid_device *hid;
 
 	struct hid_report *reports[sizeof(pidff_reports)];
+	int report_size[sizeof(pidff_reports)];
 
 	struct pidff_usage set_effect[sizeof(pidff_set_effect)];
+	struct pidff_usage set_effect_optional[
+			sizeof(pidff_set_effect_optional)];
+	struct pidff_usage block_offset[PID_AXES_MAX];
 	struct pidff_usage set_envelope[sizeof(pidff_set_envelope)];
 	struct pidff_usage set_condition[sizeof(pidff_set_condition)];
 	struct pidff_usage set_periodic[sizeof(pidff_set_periodic)];
@@ -168,6 +226,7 @@ struct pidff_device {
 	struct pidff_usage device_gain[sizeof(pidff_device_gain)];
 	struct pidff_usage block_load[sizeof(pidff_block_load)];
 	struct pidff_usage pool[sizeof(pidff_pool)];
+	struct pidff_usage pool_move[sizeof(pidff_pool_move)];
 	struct pidff_usage effect_operation[sizeof(pidff_effect_operation)];
 	struct pidff_usage block_free[sizeof(pidff_block_free)];
 
@@ -195,9 +254,299 @@ struct pidff_device {
 	int status_id[sizeof(pidff_block_load_status)];
 	int operation_id[sizeof(pidff_effect_operation_status)];
 
-	int pid_id[PID_EFFECTS_MAX];
+	unsigned int pid_total_ram, pid_used_ram;
+	int max_effects;
+
+	unsigned long flags;
+
+	struct pidff_info effect[PID_EFFECTS_MAX];
+	struct pidff_info recent;
+	int recent_effect_id;
+
+	struct pidff_memory_block *memory;
+	int alignment;
 };
 
+/* Forward declaration for functions calling lazy init */
+static void pidff_lazy_init(struct pidff_device *pidff, struct input_dev *dev);
+
+/*
+ * Calculate a report storage size in device memory, i.e. the report size
+ * minus block offsets and effect id. Calculation is used as a fallback, if
+ * device does not fill the report sizes in PID_POOL. The resulting size may
+ * not be correct, but it's the best guess we can do...
+ */
+static int pidff_calculate_report_store_size(struct hid_report *report,
+	struct pidff_usage *usage)
+{
+	if (report->field[0]->logical == (HID_UP_PID |
+			pidff_reports[PID_SET_EFFECT]))
+		return (report->size
+			- usage[PID_EFFECT_BLOCK_INDEX].field->report_size) / 8;
+	else
+		return (report->size
+			- usage[PID_PARAM_BLOCK_OFFSET].field->report_size) / 8;
+}
+
+/*
+ * Get the report size when stored into device memory.
+ */
+static int pidff_report_store_size(struct pidff_device *pidff, int report)
+{
+	int size;
+
+	size = pidff->report_size[report];
+	if (size)
+		return size;
+
+	/* Fallback, calculate size */
+	hid_warn(pidff->hid, "Calculating size for report %d.\n", report);
+	switch (report) {
+	case PID_SET_EFFECT:
+		pidff->report_size[report] = pidff_calculate_report_store_size(
+			pidff->reports[PID_SET_EFFECT], pidff->set_effect);
+		break;
+	case PID_SET_ENVELOPE:
+		pidff->report_size[report] = pidff_calculate_report_store_size(
+			pidff->reports[PID_SET_ENVELOPE], pidff->set_envelope);
+		break;
+	case PID_SET_CONDITION:
+		pidff->report_size[report] = pidff_calculate_report_store_size(
+			pidff->reports[PID_SET_CONDITION],
+			pidff->set_condition);
+		break;
+	case PID_SET_PERIODIC:
+		pidff->report_size[report] = pidff_calculate_report_store_size(
+			pidff->reports[PID_SET_PERIODIC], pidff->set_periodic);
+		break;
+	case PID_SET_CONSTANT:
+		pidff->report_size[report] = pidff_calculate_report_store_size(
+			pidff->reports[PID_SET_CONSTANT], pidff->set_constant);
+		break;
+	case PID_SET_RAMP:
+		pidff->report_size[report] = pidff_calculate_report_store_size(
+			pidff->reports[PID_SET_RAMP], pidff->set_ramp);
+		break;
+	default:
+		hid_dbg(pidff->hid, "Unknown report size queried\n");
+		return 0;
+	};
+	return pidff->report_size[report];
+}
+
+/*
+ * Find report store sizes in PID Pool report, if in driver managed mode.
+ */
+static void pidff_report_sizes(struct pidff_device *pidff)
+{
+	int i, j, k;
+	struct hid_report *report = pidff->reports[PID_POOL];
+
+	if (!report)
+		return;
+
+	for (i = 0; i < report->maxfield; i++) {
+		if (report->field[i]->maxusage !=
+				report->field[i]->report_count)
+			continue;
+
+		/* Parameter block size report = 0xA8 */
+		if ((report->field[i]->logical & 0xff) != 0xa8)
+			continue;
+
+		for (j = 0; j < report->field[i]->maxusage; j++) {
+			for (k = 0; k < sizeof(pidff_reports); k++) {
+				if (pidff_reports[k] ==
+						(report->field[i]->usage[j].hid
+						& 0xff)) {
+					pidff->report_size[k] =
+						report->field[i]->value[j];
+					break;
+				}
+			}
+		}
+		break;
+	}
+}
+
+/*
+ * Return a new free memory block offset. NULL on error.
+ */
+static struct pidff_memory_block *pidff_allocate_memory_block(
+		struct pidff_device *pidff, int size)
+{
+	struct pidff_memory_block *block, *new_block;
+	int offset, free;
+
+	if (!size)
+		return NULL;
+
+	/* Make sure alignment is as the device wants */
+	size += size % pidff->alignment;
+
+	if (pidff->pid_total_ram < (pidff->pid_used_ram + size))
+		return NULL;
+
+	if (pidff->memory == NULL) {
+		pidff->memory = kzalloc(sizeof(*pidff->memory), GFP_KERNEL);
+		if (!pidff->memory)
+			return NULL;
+
+		offset = pidff_report_store_size(pidff, PID_SET_EFFECT);
+		offset += offset % pidff->alignment;
+		offset *= pidff->max_effects;
+
+		pidff->memory[0].block_index = pidff->recent.id;
+		pidff->memory[0].block_offset = offset;
+		pidff->memory[0].size = size;
+
+		pidff->pid_used_ram = offset + size;
+		hid_dbg(pidff->hid, "Block allocated at 0x%x, size %d, ram used %d\n",
+			pidff->memory->block_offset, size, pidff->pid_used_ram);
+		return pidff->memory;
+	}
+
+	block = pidff->memory;
+	while (block) {
+		if (block->next) {
+			free = block->next->block_offset - block->block_offset
+				- block->size;
+
+			if (free >= size) {
+				new_block = kzalloc(sizeof(*pidff->memory),
+					GFP_KERNEL);
+				if (!new_block)
+					return NULL;
+
+				offset = block->block_offset + block->size;
+				new_block->block_index = pidff->recent.id;
+				new_block->block_offset = offset;
+				new_block->size = size;
+				new_block->next = block->next;
+				block->next = new_block;
+
+				pidff->pid_used_ram += size;
+
+				hid_dbg(pidff->hid, "Block allocated at 0x%x size %d, ram used%d\n",
+					new_block->block_offset, size,
+					pidff->pid_used_ram);
+				return new_block;
+			}
+		} else {
+			new_block = kzalloc(sizeof(*pidff->memory), GFP_KERNEL);
+			if (!new_block)
+				return NULL;
+
+			offset = block->block_offset + block->size;
+			new_block->block_index = pidff->recent.id;
+			new_block->block_offset = offset;
+			new_block->size = size;
+			block->next = new_block;
+
+			pidff->pid_used_ram += size;
+
+			hid_dbg(pidff->hid, "Block allocated at 0x%x size %d, ram used %d\n",
+				new_block->block_offset, size,
+				pidff->pid_used_ram);
+			return new_block;
+		}
+
+		block = block->next;
+	}
+	return NULL;
+}
+
+/*
+ * Free whole memory
+ */
+static void pidff_empty_memory(struct pidff_device *pidff)
+{
+	struct pidff_memory_block *next;
+
+	next = pidff->memory;
+	while (next) {
+		next = next->next;
+		kfree(pidff->memory);
+		pidff->memory = next;
+	}
+	pidff->memory = NULL;
+	pidff->pid_used_ram = 0;
+}
+
+/*
+ * Free an allocated memory block
+ */
+static void pidff_free_memory_block(struct pidff_device *pidff,
+		struct pidff_memory_block *block)
+{
+	struct pidff_memory_block *next;
+
+	if (block == pidff->memory) {
+		pidff->memory = block->next;
+	} else {
+		next = pidff->memory;
+		while (next) {
+			if (next->next == block) {
+				next->next = block->next;
+				break;
+			}
+			next = next->next;
+		}
+	}
+
+	pidff->pid_used_ram -= block->size;
+	kfree(block);
+}
+
+/*
+ * Get existing block or allocate a new block for effect info.
+ * Returns the offset or 0 on error.
+ */
+static int pidff_get_or_allocate_block(struct pidff_device *pidff,
+		int effect_id, int size, int n)
+{
+	int i, offset;
+	struct pidff_memory_block *block;
+
+	/* Offsets are originally from 1..., scale to 0... */
+	n--;
+	if (n < 0 || n > PID_AXES_MAX)
+		return 0;
+
+	for (i = 0; i < pidff->max_effects; i++) {
+		if (pidff->effect[i].id == effect_id) {
+			if (!pidff->effect[i].offset[n]) {
+				block = pidff_allocate_memory_block(pidff,
+						size);
+				if (!block)
+					return 0;
+
+				offset = block->block_offset;
+				block->offset_num = n;
+				pidff->effect[i].offset[n] = block;
+			} else if (pidff->effect[i].offset[n]->size == size) {
+				offset = pidff->effect[i].offset[n]->
+						block_offset;
+			} else {
+				pidff_free_memory_block(pidff, pidff->effect[i].
+						offset[n]);
+				block = pidff_allocate_memory_block(pidff,
+						size);
+				if (!block)
+					return 0;
+
+				offset = block->block_offset;
+				block->offset_num = n;
+				pidff->effect[i].offset[n] = block;
+			}
+			hid_dbg(pidff->hid, "Block for %d (%d) at 0x%x\n",
+					effect_id, n+1, offset);
+			return offset;
+		}
+	}
+	return 0;
+}
+
 /*
  * Scale an unsigned value with range 0..max for the given field
  */
@@ -219,6 +568,8 @@ static int pidff_rescale_signed(int i, s
 
 static void pidff_set(struct pidff_usage *usage, u16 value)
 {
+	if (!usage)
+		return;
 	usage->value[0] = pidff_rescale(value, 0xffff, usage->field);
 	pr_debug("calculated from %d to %d\n", value, usage->value[0]);
 }
@@ -241,11 +592,23 @@ static void pidff_set_signed(struct pidf
 /*
  * Send envelope report to the device
  */
-static void pidff_set_envelope_report(struct pidff_device *pidff,
+static int pidff_set_envelope_report(struct pidff_device *pidff,
 				      struct ff_envelope *envelope)
 {
-	pidff->set_envelope[PID_EFFECT_BLOCK_INDEX].value[0] =
-	    pidff->block_load[PID_EFFECT_BLOCK_INDEX].value[0];
+	int offset;
+
+	if (IS_DEVICE_MANAGED(pidff)) {
+		pidff->set_envelope[PID_EFFECT_BLOCK_INDEX].value[0] =
+		    pidff->recent.id;
+	} else {
+		offset = pidff_get_or_allocate_block(pidff, pidff->recent.id,
+				pidff_report_store_size(pidff,
+				PID_SET_ENVELOPE), 2);
+		if (!offset)
+			return -ENOSPC;
+
+		pidff->set_envelope[PID_PARAM_BLOCK_OFFSET].value[0] = offset;
+	}
 
 	pidff->set_envelope[PID_ATTACK_LEVEL].value[0] =
 	    pidff_rescale(envelope->attack_level >
@@ -265,6 +628,7 @@ static void pidff_set_envelope_report(st
 
 	hid_hw_request(pidff->hid, pidff->reports[PID_SET_ENVELOPE],
 			HID_REQ_SET_REPORT);
+	return 0;
 }
 
 /*
@@ -282,16 +646,30 @@ static int pidff_needs_set_envelope(stru
 /*
  * Send constant force report to the device
  */
-static void pidff_set_constant_force_report(struct pidff_device *pidff,
+static int pidff_set_constant_force_report(struct pidff_device *pidff,
 					    struct ff_effect *effect)
 {
-	pidff->set_constant[PID_EFFECT_BLOCK_INDEX].value[0] =
-		pidff->block_load[PID_EFFECT_BLOCK_INDEX].value[0];
+	int offset;
+
+	if (IS_DEVICE_MANAGED(pidff)) {
+		pidff->set_constant[PID_EFFECT_BLOCK_INDEX].value[0] =
+			pidff->recent.id;
+	} else {
+		offset = pidff_get_or_allocate_block(pidff, pidff->recent.id,
+				pidff_report_store_size(pidff,
+				PID_SET_CONSTANT), 1);
+		if (!offset)
+			return -ENOSPC;
+
+		pidff->set_constant[PID_PARAM_BLOCK_OFFSET].value[0] = offset;
+	}
+
 	pidff_set_signed(&pidff->set_constant[PID_MAGNITUDE],
 			 effect->u.constant.level);
 
 	hid_hw_request(pidff->hid, pidff->reports[PID_SET_CONSTANT],
 			HID_REQ_SET_REPORT);
+	return 0;
 }
 
 /*
@@ -310,19 +688,40 @@ static void pidff_set_effect_report(stru
 				    struct ff_effect *effect)
 {
 	pidff->set_effect[PID_EFFECT_BLOCK_INDEX].value[0] =
-		pidff->block_load[PID_EFFECT_BLOCK_INDEX].value[0];
-	pidff->set_effect_type->value[0] =
-		pidff->create_new_effect_type->value[0];
+		pidff->recent.id;
+
+	if (IS_DEVICE_MANAGED(pidff)) {
+		pidff->set_effect_type->value[0] =
+			pidff->create_new_effect_type->value[0];
+	} else {
+		pidff->set_effect_type->value[0] = pidff->recent.effect_type_id;
+		if (pidff->recent.offset[0])
+			pidff->block_offset[0].value[0] = pidff->recent.
+					offset[0]->block_offset;
+		else
+			pidff->block_offset[0].value[0] = 0;
+
+		if (pidff->recent.offset[1])
+			pidff->block_offset[1].value[0] = pidff->recent.
+					offset[1]->block_offset;
+		else
+			pidff->block_offset[1].value[0] = 0;
+	}
+
 	pidff->set_effect[PID_DURATION].value[0] = effect->replay.length;
 	pidff->set_effect[PID_TRIGGER_BUTTON].value[0] = effect->trigger.button;
 	pidff->set_effect[PID_TRIGGER_REPEAT_INT].value[0] =
 		effect->trigger.interval;
-	pidff->set_effect[PID_GAIN].value[0] =
-		pidff->set_effect[PID_GAIN].field->logical_maximum;
+	if (pidff->set_effect_optional[PID_GAIN].value)
+		pidff->set_effect_optional[PID_GAIN].value[0] =
+			pidff->set_effect_optional[PID_GAIN].field->
+						logical_maximum;
 	pidff->set_effect[PID_DIRECTION_ENABLE].value[0] = 1;
+
 	pidff->effect_direction->value[0] =
-		pidff_rescale(effect->direction, 0xffff,
-				pidff->effect_direction);
+			pidff_rescale(effect->direction, 0xffff,
+					pidff->effect_direction);
+
 	pidff->set_effect[PID_START_DELAY].value[0] = effect->replay.delay;
 
 	hid_hw_request(pidff->hid, pidff->reports[PID_SET_EFFECT],
@@ -345,11 +744,24 @@ static int pidff_needs_set_effect(struct
 /*
  * Send periodic effect report to the device
  */
-static void pidff_set_periodic_report(struct pidff_device *pidff,
+static int pidff_set_periodic_report(struct pidff_device *pidff,
 				      struct ff_effect *effect)
 {
-	pidff->set_periodic[PID_EFFECT_BLOCK_INDEX].value[0] =
-		pidff->block_load[PID_EFFECT_BLOCK_INDEX].value[0];
+	int offset;
+
+	if (IS_DEVICE_MANAGED(pidff)) {
+		pidff->set_periodic[PID_EFFECT_BLOCK_INDEX].value[0] =
+			pidff->recent.id;
+	} else {
+		offset = pidff_get_or_allocate_block(pidff, pidff->recent.id,
+				pidff_report_store_size(pidff,
+				PID_SET_PERIODIC), 1);
+		if (!offset)
+			return -ENOSPC;
+
+		pidff->set_periodic[PID_PARAM_BLOCK_OFFSET].value[0] = offset;
+	}
+
 	pidff_set_signed(&pidff->set_periodic[PID_MAGNITUDE],
 			 effect->u.periodic.magnitude);
 	pidff_set_signed(&pidff->set_periodic[PID_OFFSET],
@@ -359,7 +771,7 @@ static void pidff_set_periodic_report(st
 
 	hid_hw_request(pidff->hid, pidff->reports[PID_SET_PERIODIC],
 			HID_REQ_SET_REPORT);
-
+	return 0;
 }
 
 /*
@@ -371,22 +783,37 @@ static int pidff_needs_set_periodic(stru
 	return effect->u.periodic.magnitude != old->u.periodic.magnitude ||
 	       effect->u.periodic.offset != old->u.periodic.offset ||
 	       effect->u.periodic.phase != old->u.periodic.phase ||
+	       effect->u.periodic.phase != old->u.periodic.phase ||
 	       effect->u.periodic.period != old->u.periodic.period;
 }
 
 /*
  * Send condition effect reports to the device
  */
-static void pidff_set_condition_report(struct pidff_device *pidff,
+static int pidff_set_condition_report(struct pidff_device *pidff,
 				       struct ff_effect *effect)
 {
-	int i;
+	int i, offset;
 
-	pidff->set_condition[PID_EFFECT_BLOCK_INDEX].value[0] =
-		pidff->block_load[PID_EFFECT_BLOCK_INDEX].value[0];
+	if (IS_DEVICE_MANAGED(pidff))
+		pidff->set_condition[PID_EFFECT_BLOCK_INDEX].value[0] =
+			pidff->recent.id;
 
 	for (i = 0; i < 2; i++) {
-		pidff->set_condition[PID_PARAM_BLOCK_OFFSET].value[0] = i;
+		if (IS_DEVICE_MANAGED(pidff)) {
+			pidff->set_condition[PID_PARAM_BLOCK_OFFSET].value[0] =
+						i;
+		} else {
+			offset = pidff_get_or_allocate_block(pidff,
+				pidff->recent.id, pidff_report_store_size(pidff,
+				PID_SET_CONDITION), i+1);
+			if (!offset)
+				return -ENOSPC;
+
+			pidff->set_condition[PID_PARAM_BLOCK_OFFSET].value[0] =
+						offset;
+		}
+
 		pidff_set_signed(&pidff->set_condition[PID_CP_OFFSET],
 				 effect->u.condition[i].center);
 		pidff_set_signed(&pidff->set_condition[PID_POS_COEFFICIENT],
@@ -399,9 +826,11 @@ static void pidff_set_condition_report(s
 			  effect->u.condition[i].left_saturation);
 		pidff_set(&pidff->set_condition[PID_DEAD_BAND],
 			  effect->u.condition[i].deadband);
+
 		hid_hw_request(pidff->hid, pidff->reports[PID_SET_CONDITION],
 				HID_REQ_SET_REPORT);
 	}
+	return 0;
 }
 
 /*
@@ -431,17 +860,31 @@ static int pidff_needs_set_condition(str
 /*
  * Send ramp force report to the device
  */
-static void pidff_set_ramp_force_report(struct pidff_device *pidff,
+static int pidff_set_ramp_force_report(struct pidff_device *pidff,
 					struct ff_effect *effect)
 {
-	pidff->set_ramp[PID_EFFECT_BLOCK_INDEX].value[0] =
-		pidff->block_load[PID_EFFECT_BLOCK_INDEX].value[0];
+	int offset;
+
+	if (IS_DEVICE_MANAGED(pidff)) {
+		pidff->set_ramp[PID_EFFECT_BLOCK_INDEX].value[0] =
+			pidff->recent.id;
+	} else {
+		offset = pidff_get_or_allocate_block(pidff, pidff->recent.id,
+				pidff_report_store_size(pidff, PID_SET_RAMP),
+				1);
+		if (!offset)
+			return -ENOSPC;
+
+		pidff->set_ramp[PID_PARAM_BLOCK_OFFSET].value[0] = offset;
+	}
+
 	pidff_set_signed(&pidff->set_ramp[PID_RAMP_START],
 			 effect->u.ramp.start_level);
 	pidff_set_signed(&pidff->set_ramp[PID_RAMP_END],
 			 effect->u.ramp.end_level);
 	hid_hw_request(pidff->hid, pidff->reports[PID_SET_RAMP],
 			HID_REQ_SET_REPORT);
+	return 0;
 }
 
 /*
@@ -463,37 +906,69 @@ static int pidff_needs_set_ramp(struct f
 static int pidff_request_effect_upload(struct pidff_device *pidff, int efnum)
 {
 	int j;
+	int used[PID_EFFECTS_MAX] = {0};
 
-	pidff->create_new_effect_type->value[0] = efnum;
-	hid_hw_request(pidff->hid, pidff->reports[PID_CREATE_NEW_EFFECT],
-			HID_REQ_SET_REPORT);
-	hid_dbg(pidff->hid, "create_new_effect sent, type: %d\n", efnum);
-
-	pidff->block_load[PID_EFFECT_BLOCK_INDEX].value[0] = 0;
-	pidff->block_load_status->value[0] = 0;
-	hid_hw_wait(pidff->hid);
+	if (IS_DEVICE_MANAGED(pidff)) {
+		pidff->create_new_effect_type->value[0] = efnum;
+		hid_hw_request(pidff->hid,
+				pidff->reports[PID_CREATE_NEW_EFFECT],
+				HID_REQ_SET_REPORT);
+		hid_dbg(pidff->hid, "create_new_effect sent, type: %d\n",
+				efnum);
 
-	for (j = 0; j < 60; j++) {
-		hid_dbg(pidff->hid, "pid_block_load requested\n");
-		hid_hw_request(pidff->hid, pidff->reports[PID_BLOCK_LOAD],
-				HID_REQ_GET_REPORT);
+		pidff->block_load[PID_EFFECT_BLOCK_INDEX].value[0] = 0;
+		pidff->block_load_status->value[0] = 0;
 		hid_hw_wait(pidff->hid);
-		if (pidff->block_load_status->value[0] ==
-		    pidff->status_id[PID_BLOCK_LOAD_SUCCESS]) {
-			hid_dbg(pidff->hid, "device reported free memory: %d bytes\n",
-				 pidff->block_load[PID_RAM_POOL_AVAILABLE].value ?
-				 pidff->block_load[PID_RAM_POOL_AVAILABLE].value[0] : -1);
-			return 0;
+
+		for (j = 0; j < 60; j++) {
+			hid_dbg(pidff->hid, "pid_block_load requested\n");
+			hid_hw_request(pidff->hid,
+					pidff->reports[PID_BLOCK_LOAD],
+					HID_REQ_GET_REPORT);
+			hid_hw_wait(pidff->hid);
+			if (pidff->block_load_status->value[0] ==
+				pidff->status_id[PID_BLOCK_LOAD_SUCCESS]) {
+				hid_dbg(pidff->hid, "device reported free memory: %d bytes\n",
+					pidff->block_load[PID_RAM_POOL_AVAILABLE].value ?
+					pidff->block_load[PID_RAM_POOL_AVAILABLE].value[0] : -1);
+
+				pidff->recent.id = pidff->
+					block_load[PID_EFFECT_BLOCK_INDEX].
+					value[0];
+				return 0;
+			}
+			if (pidff->block_load_status->value[0] ==
+				pidff->status_id[PID_BLOCK_LOAD_FULL]) {
+				hid_dbg(pidff->hid, "not enough memory free: %d bytes\n",
+					pidff->block_load[PID_RAM_POOL_AVAILABLE].value ?
+					pidff->block_load[PID_RAM_POOL_AVAILABLE].value[0] : -1);
+				return -ENOSPC;
+			}
 		}
-		if (pidff->block_load_status->value[0] ==
-		    pidff->status_id[PID_BLOCK_LOAD_FULL]) {
-			hid_dbg(pidff->hid, "not enough memory free: %d bytes\n",
-				pidff->block_load[PID_RAM_POOL_AVAILABLE].value ?
-				pidff->block_load[PID_RAM_POOL_AVAILABLE].value[0] : -1);
-			return -ENOSPC;
+		hid_err(pidff->hid, "pid_block_load failed 60 times\n");
+
+	} else {
+		/* Driver managed mode, allocate a new id if any is available */
+		for (j = 0; j < pidff->max_effects; j++)
+			if (pidff->effect[j].id > -1)
+				used[pidff->effect[j].id] = 1;
+
+		for (j = 0; j < pidff->max_effects; j++) {
+			if (used[j])
+				continue;
+
+			pidff->effect[pidff->recent_effect_id].id =
+					pidff->recent.id = j;
+			pidff->effect[pidff->recent_effect_id].offset[0] = NULL;
+			pidff->effect[pidff->recent_effect_id].offset[1] = NULL;
+			pidff->effect[pidff->recent_effect_id].effect_type_id =
+					pidff->recent.effect_type_id = efnum;
+
+			hid_dbg(pidff->hid, "upload id %d\n", pidff->recent.id);
+			return 0;
 		}
+		return -ENOSPC;
 	}
-	hid_err(pidff->hid, "pid_block_load failed 60 times\n");
 	return -EIO;
 }
 
@@ -524,7 +999,7 @@ static int pidff_playback(struct input_d
 {
 	struct pidff_device *pidff = dev->ff->private;
 
-	pidff_playback_pid(pidff, pidff->pid_id[effect_id], value);
+	pidff_playback_pid(pidff, pidff->effect[effect_id].id, value);
 
 	return 0;
 }
@@ -534,9 +1009,25 @@ static int pidff_playback(struct input_d
  */
 static void pidff_erase_pid(struct pidff_device *pidff, int pid_id)
 {
-	pidff->block_free[PID_EFFECT_BLOCK_INDEX].value[0] = pid_id;
-	hid_hw_request(pidff->hid, pidff->reports[PID_BLOCK_FREE],
-			HID_REQ_SET_REPORT);
+	struct pidff_memory_block *block, *b2;
+
+	if (IS_DEVICE_MANAGED(pidff)) {
+		pidff->block_free[PID_EFFECT_BLOCK_INDEX].value[0] = pid_id;
+		hid_hw_request(pidff->hid, pidff->reports[PID_BLOCK_FREE],
+				HID_REQ_SET_REPORT);
+	} else {
+		block = pidff->memory;
+		while (block) {
+			b2 = block;
+			block = block->next;
+
+			if (b2->block_index == pid_id) {
+				hid_dbg(pidff->hid, "Block erased at 0x%x\n",
+					b2->block_offset);
+				pidff_free_memory_block(pidff, b2);
+			}
+		}
+	}
 }
 
 /*
@@ -545,16 +1036,20 @@ static void pidff_erase_pid(struct pidff
 static int pidff_erase_effect(struct input_dev *dev, int effect_id)
 {
 	struct pidff_device *pidff = dev->ff->private;
-	int pid_id = pidff->pid_id[effect_id];
+	int pid_id = pidff->effect[effect_id].id;
 
 	hid_dbg(pidff->hid, "starting to erase %d/%d\n",
-		effect_id, pidff->pid_id[effect_id]);
+		effect_id, pidff->effect[effect_id].id);
 	/* Wait for the queue to clear. We do not want a full fifo to
 	   prevent the effect removal. */
 	hid_hw_wait(pidff->hid);
 	pidff_playback_pid(pidff, pid_id, 0);
 	pidff_erase_pid(pidff, pid_id);
 
+	pidff->effect[effect_id].id = -1;
+	pidff->effect[effect_id].offset[0] = NULL;
+	pidff->effect[effect_id].offset[1] = NULL;
+
 	return 0;
 }
 
@@ -565,26 +1060,37 @@ static int pidff_upload_effect(struct in
 			       struct ff_effect *old)
 {
 	struct pidff_device *pidff = dev->ff->private;
-	int type_id;
-	int error;
+	int type_id = 0, error = 0;
+	int needs_set_effect = 0;
+	int (*needs_set_report)(struct ff_effect *, struct ff_effect *) = NULL;
+	int (*set_report_func)(struct pidff_device *, struct ff_effect *) =
+			NULL;
+	struct ff_envelope *envelope = NULL, *old_envelope = NULL;
+
+	if (!IS_LAZY_INITIALIZED(pidff))
+		pidff_lazy_init(pidff, dev);
+
+	pidff->recent_effect_id = effect->id;
+	if (old) {
+		pidff->recent.id = pidff->effect[effect->id].id;
+		pidff->recent.offset[0] = pidff->effect[effect->id].offset[0];
+		pidff->recent.offset[1] = pidff->effect[effect->id].offset[1];
+
+		if (pidff_needs_set_effect(effect, old))
+			needs_set_effect = 1;
+	} else {
+		pidff->recent.offset[0] = NULL;
+		pidff->recent.offset[1] = NULL;
+		needs_set_effect = 1;
+	}
 
 	switch (effect->type) {
 	case FF_CONSTANT:
-		if (!old) {
-			error = pidff_request_effect_upload(pidff,
-					pidff->type_id[PID_CONSTANT]);
-			if (error)
-				return error;
-		}
-		if (!old || pidff_needs_set_effect(effect, old))
-			pidff_set_effect_report(pidff, effect);
-		if (!old || pidff_needs_set_constant(effect, old))
-			pidff_set_constant_force_report(pidff, effect);
-		if (!old ||
-		    pidff_needs_set_envelope(&effect->u.constant.envelope,
-					&old->u.constant.envelope))
-			pidff_set_envelope_report(pidff,
-					&effect->u.constant.envelope);
+		needs_set_report = pidff_needs_set_constant;
+		set_report_func = pidff_set_constant_force_report;
+		envelope = &effect->u.constant.envelope;
+		old_envelope = &old->u.constant.envelope;
+		type_id = PID_CONSTANT;
 		break;
 
 	case FF_PERIODIC:
@@ -609,91 +1115,44 @@ static int pidff_upload_effect(struct in
 				hid_err(pidff->hid, "invalid waveform\n");
 				return -EINVAL;
 			}
-
-			error = pidff_request_effect_upload(pidff,
-					pidff->type_id[type_id]);
-			if (error)
-				return error;
 		}
-		if (!old || pidff_needs_set_effect(effect, old))
-			pidff_set_effect_report(pidff, effect);
-		if (!old || pidff_needs_set_periodic(effect, old))
-			pidff_set_periodic_report(pidff, effect);
-		if (!old ||
-		    pidff_needs_set_envelope(&effect->u.periodic.envelope,
-					&old->u.periodic.envelope))
-			pidff_set_envelope_report(pidff,
-					&effect->u.periodic.envelope);
+
+		needs_set_report = pidff_needs_set_periodic;
+		set_report_func = pidff_set_periodic_report;
+		envelope = &effect->u.periodic.envelope;
+		old_envelope = &old->u.periodic.envelope;
 		break;
 
 	case FF_RAMP:
-		if (!old) {
-			error = pidff_request_effect_upload(pidff,
-					pidff->type_id[PID_RAMP]);
-			if (error)
-				return error;
-		}
-		if (!old || pidff_needs_set_effect(effect, old))
-			pidff_set_effect_report(pidff, effect);
-		if (!old || pidff_needs_set_ramp(effect, old))
-			pidff_set_ramp_force_report(pidff, effect);
-		if (!old ||
-		    pidff_needs_set_envelope(&effect->u.ramp.envelope,
-					&old->u.ramp.envelope))
-			pidff_set_envelope_report(pidff,
-					&effect->u.ramp.envelope);
+		needs_set_report = pidff_needs_set_ramp;
+		set_report_func = pidff_set_ramp_force_report;
+		envelope = &effect->u.ramp.envelope;
+		old_envelope = &old->u.ramp.envelope;
+		type_id = PID_RAMP;
 		break;
 
 	case FF_SPRING:
-		if (!old) {
-			error = pidff_request_effect_upload(pidff,
-					pidff->type_id[PID_SPRING]);
-			if (error)
-				return error;
-		}
-		if (!old || pidff_needs_set_effect(effect, old))
-			pidff_set_effect_report(pidff, effect);
-		if (!old || pidff_needs_set_condition(effect, old))
-			pidff_set_condition_report(pidff, effect);
+		needs_set_report = pidff_needs_set_condition;
+		set_report_func = pidff_set_condition_report;
+		type_id = PID_SPRING;
 		break;
 
 	case FF_FRICTION:
-		if (!old) {
-			error = pidff_request_effect_upload(pidff,
-					pidff->type_id[PID_FRICTION]);
-			if (error)
-				return error;
-		}
-		if (!old || pidff_needs_set_effect(effect, old))
-			pidff_set_effect_report(pidff, effect);
-		if (!old || pidff_needs_set_condition(effect, old))
-			pidff_set_condition_report(pidff, effect);
+		needs_set_report = pidff_needs_set_condition;
+		set_report_func = pidff_set_condition_report;
+		type_id = PID_FRICTION;
 		break;
 
 	case FF_DAMPER:
-		if (!old) {
-			error = pidff_request_effect_upload(pidff,
-					pidff->type_id[PID_DAMPER]);
-			if (error)
-				return error;
-		}
-		if (!old || pidff_needs_set_effect(effect, old))
-			pidff_set_effect_report(pidff, effect);
-		if (!old || pidff_needs_set_condition(effect, old))
-			pidff_set_condition_report(pidff, effect);
+		needs_set_report = pidff_needs_set_condition;
+		set_report_func = pidff_set_condition_report;
+		type_id = PID_DAMPER;
 		break;
 
 	case FF_INERTIA:
-		if (!old) {
-			error = pidff_request_effect_upload(pidff,
-					pidff->type_id[PID_INERTIA]);
-			if (error)
-				return error;
-		}
-		if (!old || pidff_needs_set_effect(effect, old))
-			pidff_set_effect_report(pidff, effect);
-		if (!old || pidff_needs_set_condition(effect, old))
-			pidff_set_condition_report(pidff, effect);
+		needs_set_report = pidff_needs_set_condition;
+		set_report_func = pidff_set_condition_report;
+		type_id = PID_INERTIA;
 		break;
 
 	default:
@@ -701,13 +1160,56 @@ static int pidff_upload_effect(struct in
 		return -EINVAL;
 	}
 
-	if (!old)
-		pidff->pid_id[effect->id] =
-		    pidff->block_load[PID_EFFECT_BLOCK_INDEX].value[0];
+	if (!old) {
+		error = pidff_request_effect_upload(pidff,
+				pidff->type_id[type_id]);
+		if (error)
+			return error;
+	}
+
+	if (needs_set_effect && IS_DEVICE_MANAGED(pidff))
+		pidff_set_effect_report(pidff, effect);
+
+	if ((!old || (needs_set_report && (*needs_set_report)(effect, old))) &&
+		set_report_func) {
+		error = (*set_report_func)(pidff, effect);
+		if (error)
+			goto fail;
+	}
+
+	if (envelope &&	(!old ||
+			pidff_needs_set_envelope(envelope, old_envelope))) {
+		error = pidff_set_envelope_report(pidff, envelope);
+		if (error)
+			goto fail;
+	}
+
+	if (!IS_DEVICE_MANAGED(pidff)) {
+		if (!old || pidff->recent.offset[0] !=
+				pidff->effect[effect->id].offset[0] ||
+				pidff->recent.offset[1] !=
+				pidff->effect[effect->id].offset[1]) {
+			pidff->recent.offset[0] =
+				pidff->effect[effect->id].offset[0];
+			pidff->recent.offset[1] =
+				pidff->effect[effect->id].offset[1];
+			pidff_set_effect_report(pidff, effect);
+		}
+	}
 
 	hid_dbg(pidff->hid, "uploaded\n");
-
+	pidff->recent.id = -1;
+	pidff->recent.offset[0]	= NULL;
+	pidff->recent.offset[1] = NULL;
 	return 0;
+
+fail:
+	hid_dbg(pidff->hid, "upload failed\n");
+	pidff_erase_pid(pidff, pidff->recent.id);
+	pidff->recent.id = -1;
+	pidff->recent.offset[0]	= NULL;
+	pidff->recent.offset[1] = NULL;
+	return error;
 }
 
 /*
@@ -724,28 +1226,34 @@ static void pidff_set_gain(struct input_
 
 static void pidff_autocenter(struct pidff_device *pidff, u16 magnitude)
 {
-	struct hid_field *field =
-		pidff->block_load[PID_EFFECT_BLOCK_INDEX].field;
+	struct hid_field *field;
 
-	if (!magnitude) {
-		pidff_playback_pid(pidff, field->logical_minimum, 0);
-		return;
-	}
+	if (IS_DEVICE_MANAGED(pidff)) {
+		field = pidff->block_load[PID_EFFECT_BLOCK_INDEX].field;
 
-	pidff_playback_pid(pidff, field->logical_minimum, 1);
+		if (!magnitude) {
+			pidff_playback_pid(pidff, field->logical_minimum, 0);
+			return;
+		}
 
-	pidff->set_effect[PID_EFFECT_BLOCK_INDEX].value[0] =
-		pidff->block_load[PID_EFFECT_BLOCK_INDEX].field->logical_minimum;
-	pidff->set_effect_type->value[0] = pidff->type_id[PID_SPRING];
-	pidff->set_effect[PID_DURATION].value[0] = 0;
-	pidff->set_effect[PID_TRIGGER_BUTTON].value[0] = 0;
-	pidff->set_effect[PID_TRIGGER_REPEAT_INT].value[0] = 0;
-	pidff_set(&pidff->set_effect[PID_GAIN], magnitude);
-	pidff->set_effect[PID_DIRECTION_ENABLE].value[0] = 1;
-	pidff->set_effect[PID_START_DELAY].value[0] = 0;
+		pidff_playback_pid(pidff, field->logical_minimum, 1);
 
-	hid_hw_request(pidff->hid, pidff->reports[PID_SET_EFFECT],
-			HID_REQ_SET_REPORT);
+		pidff->set_effect[PID_EFFECT_BLOCK_INDEX].value[0] =
+			pidff->block_load[PID_EFFECT_BLOCK_INDEX].field->
+			logical_minimum;
+
+		pidff->set_effect_type->value[0] = pidff->type_id[PID_SPRING];
+
+		pidff->set_effect[PID_DURATION].value[0] = 0;
+		pidff->set_effect[PID_TRIGGER_BUTTON].value[0] = 0;
+		pidff->set_effect[PID_TRIGGER_REPEAT_INT].value[0] = 0;
+		pidff_set(&pidff->set_effect_optional[PID_GAIN], magnitude);
+		pidff->set_effect[PID_DIRECTION_ENABLE].value[0] = 1;
+		pidff->set_effect[PID_START_DELAY].value[0] = 0;
+
+		hid_hw_request(pidff->hid, pidff->reports[PID_SET_EFFECT],
+				HID_REQ_SET_REPORT);
+	}
 }
 
 /*
@@ -755,6 +1263,9 @@ static void pidff_set_autocenter(struct
 {
 	struct pidff_device *pidff = dev->ff->private;
 
+	if (!IS_LAZY_INITIALIZED(pidff))
+		pidff_lazy_init(pidff, dev);
+
 	pidff_autocenter(pidff, magnitude);
 }
 
@@ -762,12 +1273,22 @@ static void pidff_set_autocenter(struct
  * Find fields from a report and fill a pidff_usage
  */
 static int pidff_find_fields(struct pidff_usage *usage, const u8 *table,
-			     struct hid_report *report, int count, int strict)
+		struct hid_report *report, int count, int strict,
+		struct pidff_device *dev)
 {
-	int i, j, k, found;
+	int i, j, k, found, key, offset;
 
 	for (k = 0; k < count; k++) {
 		found = 0;
+
+		key = table[k];
+		if (key == PID_INDEX_PLACEHOLDER) {
+			if (IS_DEVICE_MANAGED(dev))
+				key = PID_EFFECT_BLOCK_INDEX_CODE;
+			else
+				key = PID_PARAM_BLOCK_OFFSET_CODE;
+		}
+
 		for (i = 0; i < report->maxfield; i++) {
 			if (report->field[i]->maxusage !=
 			    report->field[i]->report_count) {
@@ -776,21 +1297,36 @@ static int pidff_find_fields(struct pidf
 			}
 			for (j = 0; j < report->field[i]->maxusage; j++) {
 				if (report->field[i]->usage[j].hid ==
-				    (HID_UP_PID | table[k])) {
-					pr_debug("found %d at %d->%d\n",
-						 k, i, j);
+				    (HID_UP_PID | key)) {
+					pr_debug("found %d at %d->%d (0x%02d)\n",
+						 k, i, j, key);
 					usage[k].field = report->field[i];
 					usage[k].value =
 						&report->field[i]->value[j];
 					found = 1;
 					break;
 				}
+
+				/* Find block offsets for set effect report */
+				if ((report->field[i]->logical & 0xff) ==
+						0x58) {
+					offset = (report->field[i]->usage[j].hid
+						& 0xff) - 1;
+					if (offset >= 0 && offset <
+							PID_AXES_MAX) {
+						dev->block_offset[offset].field
+							= report->field[i];
+						dev->block_offset[offset].value
+							= &report->field[i]->
+							value[j];
+					}
+				}
 			}
 			if (found)
 				break;
-		}
+			}
 		if (!found && strict) {
-			pr_debug("failed to locate %d\n", k);
+			pr_debug("failed to locate %d (0x%02x)\n", k, table[k]);
 			return -1;
 		}
 	}
@@ -827,8 +1363,8 @@ static void pidff_find_reports(struct hi
 			continue;
 		ret = pidff_check_usage(report->field[0]->logical);
 		if (ret != -1) {
-			hid_dbg(hid, "found usage 0x%02x from field->logical\n",
-				pidff_reports[ret]);
+			hid_dbg(hid, "found usage 0x%02x from field->logical, size %d\n",
+				pidff_reports[ret], report->size);
 			pidff->reports[ret] = report;
 			continue;
 		}
@@ -847,8 +1383,8 @@ static void pidff_find_reports(struct hi
 		ret = pidff_check_usage(hid->collection[i - 1].usage);
 		if (ret != -1 && !pidff->reports[ret]) {
 			hid_dbg(hid,
-				"found usage 0x%02x from collection array\n",
-				pidff_reports[ret]);
+				"found usage 0x%02x from collection array, size %d\n",
+				pidff_reports[ret], report->size);
 			pidff->reports[ret] = report;
 		}
 	}
@@ -861,6 +1397,7 @@ static int pidff_reports_ok(struct pidff
 {
 	int i;
 
+	/* Check for reports requried for all devices */
 	for (i = 0; i <= PID_REQUIRED_REPORTS; i++) {
 		if (!pidff->reports[i]) {
 			hid_dbg(pidff->hid, "%d missing\n", i);
@@ -868,6 +1405,26 @@ static int pidff_reports_ok(struct pidff
 		}
 	}
 
+	/* Check for reports required for device managed mode */
+	for (; i <= PID_REQUIRED_DEVICE_MANAGED; i++) {
+		if (!pidff->reports[i]) {
+			hid_dbg(pidff->hid, "%d missing for device managed\n",
+				i);
+			clear_bit(PID_SUPPORTS_DEVICE_MANAGED, &pidff->flags);
+			break;
+		}
+	}
+
+	/* Check for reports required for pool move (garbage collect) */
+	for (i = PID_REQUIRED_DEVICE_MANAGED; i <= PID_REQUIRED_POOL_MOVE;
+						i++) {
+		if (!pidff->reports[i]) {
+			hid_dbg(pidff->hid, "%d missing for pool moving\n", i);
+			clear_bit(PID_SUPPORTS_POOL_MOVE, &pidff->flags);
+			break;
+		}
+	}
+
 	return 1;
 }
 
@@ -890,6 +1447,16 @@ static struct hid_field *pidff_find_spec
 				return NULL;
 			}
 		}
+		if (((report->field[i]->usage[0].hid & 0xff) == usage) &&
+		    report->field[i]->report_count > 0) {
+			if (!enforce_min ||
+			    report->field[i]->logical_minimum == 1)
+				return report->field[i];
+			else {
+				pr_err("logical_minimum is not 1 as it should be\n");
+				return NULL;
+			}
+		}
 	}
 	return NULL;
 }
@@ -919,7 +1486,6 @@ static int pidff_find_special_keys(int *
 #define PIDFF_FIND_SPECIAL_KEYS(keys, field, name) \
 	pidff_find_special_keys(pidff->keys, pidff->field, pidff_ ## name, \
 		sizeof(pidff_ ## name))
-
 /*
  * Find and check the special fields
  */
@@ -927,9 +1493,6 @@ static int pidff_find_special_fields(str
 {
 	hid_dbg(pidff->hid, "finding special fields\n");
 
-	pidff->create_new_effect_type =
-		pidff_find_special_field(pidff->reports[PID_CREATE_NEW_EFFECT],
-					 0x25, 1);
 	pidff->set_effect_type =
 		pidff_find_special_field(pidff->reports[PID_SET_EFFECT],
 					 0x25, 1);
@@ -939,16 +1502,23 @@ static int pidff_find_special_fields(str
 	pidff->device_control =
 		pidff_find_special_field(pidff->reports[PID_DEVICE_CONTROL],
 					 0x96, 1);
-	pidff->block_load_status =
-		pidff_find_special_field(pidff->reports[PID_BLOCK_LOAD],
-					 0x8b, 1);
 	pidff->effect_operation_status =
 		pidff_find_special_field(pidff->reports[PID_EFFECT_OPERATION],
 					 0x78, 1);
 
+	if (IS_DEVICE_MANAGED(pidff)) {
+		pidff->create_new_effect_type =
+			pidff_find_special_field(
+			pidff->reports[PID_CREATE_NEW_EFFECT], 0x25, 1);
+		pidff->block_load_status =
+			pidff_find_special_field(pidff->reports[PID_BLOCK_LOAD],
+						0x8b, 1);
+	}
+
 	hid_dbg(pidff->hid, "search done\n");
 
-	if (!pidff->create_new_effect_type || !pidff->set_effect_type) {
+	if ((!pidff->create_new_effect_type && IS_DEVICE_MANAGED(pidff))
+			|| !pidff->set_effect_type) {
 		hid_err(pidff->hid, "effect lists not found\n");
 		return -1;
 	}
@@ -963,7 +1533,7 @@ static int pidff_find_special_fields(str
 		return -1;
 	}
 
-	if (!pidff->block_load_status) {
+	if (!pidff->block_load_status && IS_DEVICE_MANAGED(pidff)) {
 		hid_err(pidff->hid, "block load status field not found\n");
 		return -1;
 	}
@@ -979,18 +1549,27 @@ static int pidff_find_special_fields(str
 
 	PIDFF_FIND_SPECIAL_KEYS(control_id, device_control, device_control);
 
-	if (!PIDFF_FIND_SPECIAL_KEYS(type_id, create_new_effect_type,
-				     effect_types)) {
-		hid_err(pidff->hid, "no effect types found\n");
-		return -1;
-	}
+	if (IS_DEVICE_MANAGED(pidff)) {
+		if (!PIDFF_FIND_SPECIAL_KEYS(type_id, create_new_effect_type,
+						effect_types)) {
+			hid_err(pidff->hid, "no effect types found\n");
+			return -1;
+		}
 
-	if (PIDFF_FIND_SPECIAL_KEYS(status_id, block_load_status,
-				    block_load_status) !=
-			sizeof(pidff_block_load_status)) {
-		hid_err(pidff->hid,
-			"block load status identifiers not found\n");
-		return -1;
+		if (PIDFF_FIND_SPECIAL_KEYS(status_id, block_load_status,
+						block_load_status) !=
+				sizeof(pidff_block_load_status)) {
+			hid_err(pidff->hid,
+				"block load status identifiers not found\n");
+			return -1;
+		}
+
+	} else {
+		if (!PIDFF_FIND_SPECIAL_KEYS(type_id, set_effect_type,
+						effect_types)) {
+			hid_err(pidff->hid, "no effect types found\n");
+			return -1;
+		}
 	}
 
 	if (PIDFF_FIND_SPECIAL_KEYS(operation_id, effect_operation_status,
@@ -1011,13 +1590,17 @@ static int pidff_find_effects(struct pid
 {
 	int i;
 
-	for (i = 0; i < sizeof(pidff_effect_types); i++) {
-		int pidff_type = pidff->type_id[i];
-		if (pidff->set_effect_type->usage[pidff_type].hid !=
-		    pidff->create_new_effect_type->usage[pidff_type].hid) {
-			hid_err(pidff->hid,
-				"effect type number %d is invalid\n", i);
-			return -1;
+	if (IS_DEVICE_MANAGED(pidff)) {
+		for (i = 0; i < sizeof(pidff_effect_types); i++) {
+			int pidff_type = pidff->type_id[i];
+			if (pidff->set_effect_type->usage[pidff_type].hid !=
+				pidff->create_new_effect_type->
+						usage[pidff_type].hid) {
+				hid_err(pidff->hid,
+					"effect type number %d is invalid\n",
+					i);
+				return -1;
+			}
 		}
 	}
 
@@ -1058,10 +1641,10 @@ static int pidff_find_effects(struct pid
 
 }
 
-#define PIDFF_FIND_FIELDS(name, report, strict) \
+#define PIDFF_FIND_FIELDS(name, report, strict, dev) \
 	pidff_find_fields(pidff->name, pidff_ ## name, \
 		pidff->reports[report], \
-		sizeof(pidff_ ## name), strict)
+		sizeof(pidff_ ## name), strict, dev)
 
 /*
  * Fill and check the pidff_usages
@@ -1070,28 +1653,25 @@ static int pidff_init_fields(struct pidf
 {
 	int envelope_ok = 0;
 
-	if (PIDFF_FIND_FIELDS(set_effect, PID_SET_EFFECT, 1)) {
+	if (PIDFF_FIND_FIELDS(set_effect, PID_SET_EFFECT, 1, pidff)) {
 		hid_err(pidff->hid, "unknown set_effect report layout\n");
 		return -ENODEV;
 	}
+	PIDFF_FIND_FIELDS(set_effect_optional, PID_SET_EFFECT, 0, pidff);
 
-	PIDFF_FIND_FIELDS(block_load, PID_BLOCK_LOAD, 0);
-	if (!pidff->block_load[PID_EFFECT_BLOCK_INDEX].value) {
-		hid_err(pidff->hid, "unknown pid_block_load report layout\n");
+	/* Check block offsets TODO: Currently hard coded 2 axis */
+	if (!pidff->block_offset[0].field || !pidff->block_offset[1].field) {
+		hid_err(pidff->hid, "unknown set_effect report layout (type spec. block offsets)\n");
 		return -ENODEV;
 	}
 
-	if (PIDFF_FIND_FIELDS(effect_operation, PID_EFFECT_OPERATION, 1)) {
+	if (PIDFF_FIND_FIELDS(effect_operation, PID_EFFECT_OPERATION,
+					1, pidff)) {
 		hid_err(pidff->hid, "unknown effect_operation report layout\n");
 		return -ENODEV;
 	}
 
-	if (PIDFF_FIND_FIELDS(block_free, PID_BLOCK_FREE, 1)) {
-		hid_err(pidff->hid, "unknown pid_block_free report layout\n");
-		return -ENODEV;
-	}
-
-	if (!PIDFF_FIND_FIELDS(set_envelope, PID_SET_ENVELOPE, 1))
+	if (!PIDFF_FIND_FIELDS(set_envelope, PID_SET_ENVELOPE, 1, pidff))
 		envelope_ok = 1;
 
 	if (pidff_find_special_fields(pidff) || pidff_find_effects(pidff, dev))
@@ -1111,13 +1691,13 @@ static int pidff_init_fields(struct pidf
 	}
 
 	if (test_bit(FF_CONSTANT, dev->ffbit) &&
-	    PIDFF_FIND_FIELDS(set_constant, PID_SET_CONSTANT, 1)) {
+	    PIDFF_FIND_FIELDS(set_constant, PID_SET_CONSTANT, 1, pidff)) {
 		hid_warn(pidff->hid, "unknown constant effect layout\n");
 		clear_bit(FF_CONSTANT, dev->ffbit);
 	}
 
 	if (test_bit(FF_RAMP, dev->ffbit) &&
-	    PIDFF_FIND_FIELDS(set_ramp, PID_SET_RAMP, 1)) {
+	    PIDFF_FIND_FIELDS(set_ramp, PID_SET_RAMP, 1, pidff)) {
 		hid_warn(pidff->hid, "unknown ramp effect layout\n");
 		clear_bit(FF_RAMP, dev->ffbit);
 	}
@@ -1126,7 +1706,7 @@ static int pidff_init_fields(struct pidf
 	     test_bit(FF_DAMPER, dev->ffbit) ||
 	     test_bit(FF_FRICTION, dev->ffbit) ||
 	     test_bit(FF_INERTIA, dev->ffbit)) &&
-	    PIDFF_FIND_FIELDS(set_condition, PID_SET_CONDITION, 1)) {
+	    PIDFF_FIND_FIELDS(set_condition, PID_SET_CONDITION, 1, pidff)) {
 		hid_warn(pidff->hid, "unknown condition effect layout\n");
 		clear_bit(FF_SPRING, dev->ffbit);
 		clear_bit(FF_DAMPER, dev->ffbit);
@@ -1135,16 +1715,36 @@ static int pidff_init_fields(struct pidf
 	}
 
 	if (test_bit(FF_PERIODIC, dev->ffbit) &&
-	    PIDFF_FIND_FIELDS(set_periodic, PID_SET_PERIODIC, 1)) {
+	    PIDFF_FIND_FIELDS(set_periodic, PID_SET_PERIODIC, 1, pidff)) {
 		hid_warn(pidff->hid, "unknown periodic effect layout\n");
 		clear_bit(FF_PERIODIC, dev->ffbit);
 	}
 
-	PIDFF_FIND_FIELDS(pool, PID_POOL, 0);
+	PIDFF_FIND_FIELDS(pool, PID_POOL, 0, pidff);
 
-	if (!PIDFF_FIND_FIELDS(device_gain, PID_DEVICE_GAIN, 1))
+	if (!PIDFF_FIND_FIELDS(device_gain, PID_DEVICE_GAIN, 1, pidff))
 		set_bit(FF_GAIN, dev->ffbit);
 
+	if (IS_DEVICE_MANAGED(pidff)) {
+		PIDFF_FIND_FIELDS(block_load, PID_BLOCK_LOAD, 0, pidff);
+		if (!pidff->block_load[PID_EFFECT_BLOCK_INDEX].value) {
+			hid_err(pidff->hid, "unknown pid_block_load report layout\n");
+			return -ENODEV;
+		}
+
+		if (PIDFF_FIND_FIELDS(block_free, PID_BLOCK_FREE, 1, pidff)) {
+			hid_err(pidff->hid, "unknown pid_block_free report layout\n");
+			return -ENODEV;
+		}
+	}
+
+	if (test_bit(PID_SUPPORTS_POOL_MOVE, &pidff->flags)) {
+		if (PIDFF_FIND_FIELDS(pool_move, PID_POOL_MOVE, 0, pidff)) {
+			hid_err(pidff->hid, "unknown pid_pool_move report layout\n");
+			return -ENODEV;
+		}
+	}
+
 	return 0;
 }
 
@@ -1154,7 +1754,8 @@ static int pidff_init_fields(struct pidf
 static void pidff_reset(struct pidff_device *pidff)
 {
 	struct hid_device *hid = pidff->hid;
-	int i = 0;
+
+	pidff_empty_memory(pidff);
 
 	pidff->device_control->value[0] = pidff->control_id[PID_RESET];
 	/* We reset twice as sometimes hid_wait_io isn't waiting long enough */
@@ -1167,63 +1768,154 @@ static void pidff_reset(struct pidff_dev
 		pidff->control_id[PID_ENABLE_ACTUATORS];
 	hid_hw_request(hid, pidff->reports[PID_DEVICE_CONTROL], HID_REQ_SET_REPORT);
 	hid_hw_wait(hid);
+}
+
+/*
+ * Test if autocenter modification is using the supported method
+ */
+static int pidff_check_autocenter(struct pidff_device *pidff,
+				  struct input_dev *dev)
+{
+	int error;
+	/*struct ff_effect autocenter; */
+
+	if (IS_DEVICE_MANAGED(pidff)) {
+		/*
+		* Let's find out if autocenter modification is supported
+		* Specification doesn't specify anything, so we request an
+		* effect upload and cancel it immediately. If the approved
+		* effect id was one above the minimum, then we assume the first
+		* effect id is a built-in spring type effect used for autocenter
+		*/
+
+		error = pidff_request_effect_upload(pidff, 1);
+		if (error) {
+			hid_err(pidff->hid, "upload request failed\n");
+			return error;
+		}
+
+		if (pidff->recent.id ==
+				pidff->block_load[PID_EFFECT_BLOCK_INDEX].
+				field->logical_minimum + 1) {
+			pidff_autocenter(pidff, 0xffff);
+			set_bit(FF_AUTOCENTER, dev->ffbit);
+		} else {
+			hid_notice(pidff->hid,
+				"device has unknown autocenter control method\n");
+		}
+
+		pidff_erase_pid(pidff, pidff->recent.id);
+	} else {
+		/*
+		 * In driver managed mode, there is no way of knowing if a
+		 * pre-configured spring effect exists or not, so if spring
+		 * is supported, make first effect autocenter
+		 */
+		 if (!test_bit(FF_SPRING, dev->ffbit))
+			return 0;
+
+/*
+		error = pidff_request_effect_upload(pidff,
+				pidff->type_id[PID_SPRING]);
+		if (error)
+			return error;
+
+		autocenter.type = FF_SPRING;
+		autocenter.
+
+		pidff_set_condition_report(pidff, effect);
+		pidff_set_effect_report(pidff, effect);
+*/
+		/* TODO: Not yet supported... */
+		return 0;
+	}
+
+	return 0;
+
+}
+
+/*
+ * Do a "lazy" initialization, because reports are discarded
+ * until probe (init) is done
+ */
+static void pidff_lazy_init(struct pidff_device *pidff, struct input_dev *dev)
+{
+	int i = 0;
+
+	set_bit(PID_IS_LAZY_INITIALIZED, &pidff->flags);
 
 	/* pool report is sometimes messed up, refetch it */
-	hid_hw_request(hid, pidff->reports[PID_POOL], HID_REQ_GET_REPORT);
-	hid_hw_wait(hid);
+	hid_hw_request(pidff->hid, pidff->reports[PID_POOL],
+			HID_REQ_GET_REPORT);
+	hid_hw_wait(pidff->hid);
 
 	if (pidff->pool[PID_SIMULTANEOUS_MAX].value) {
 		while (pidff->pool[PID_SIMULTANEOUS_MAX].value[0] < 2) {
-			if (i++ > 20) {
+			if (i++ > 2) {
 				hid_warn(pidff->hid,
 					 "device reports %d simultaneous effects\n",
 					 pidff->pool[PID_SIMULTANEOUS_MAX].value[0]);
 				break;
 			}
 			hid_dbg(pidff->hid, "pid_pool requested again\n");
-			hid_hw_request(hid, pidff->reports[PID_POOL],
+			hid_hw_request(pidff->hid, pidff->reports[PID_POOL],
 					  HID_REQ_GET_REPORT);
-			hid_hw_wait(hid);
+			hid_hw_wait(pidff->hid);
 		}
 	}
-}
 
-/*
- * Test if autocenter modification is using the supported method
- */
-static int pidff_check_autocenter(struct pidff_device *pidff,
-				  struct input_dev *dev)
-{
-	int error;
-
-	/*
-	 * Let's find out if autocenter modification is supported
-	 * Specification doesn't specify anything, so we request an
-	 * effect upload and cancel it immediately. If the approved
-	 * effect id was one above the minimum, then we assume the first
-	 * effect id is a built-in spring type effect used for autocenter
-	 */
-
-	error = pidff_request_effect_upload(pidff, 1);
-	if (error) {
-		hid_err(pidff->hid, "upload request failed\n");
-		return error;
-	}
-
-	if (pidff->block_load[PID_EFFECT_BLOCK_INDEX].value[0] ==
-	    pidff->block_load[PID_EFFECT_BLOCK_INDEX].field->logical_minimum + 1) {
-		pidff_autocenter(pidff, 0xffff);
-		set_bit(FF_AUTOCENTER, dev->ffbit);
-	} else {
+	for (i = 0; i < PID_EFFECTS_MAX; i++) {
+		pidff->effect[i].id = -1;
+		pidff->effect[i].offset[0] = NULL;
+		pidff->effect[i].offset[1] = NULL;
+	}
+
+	if (pidff->pool[PID_RAM_POOL_SIZE].value &&
+			pidff->pool[PID_RAM_POOL_SIZE].value[0] > 0) {
+		pidff->pid_total_ram = pidff->pool[PID_RAM_POOL_SIZE].value[0];
+	} else if (pidff->block_offset[0].field) {
+		pidff->pid_total_ram =
+				pidff->block_offset[0].field->logical_maximum
+				- pidff->block_offset[0].field->logical_minimum
+				+ 1;
+	}
+	hid_dbg(pidff->hid, "device memory size is %d bytes\n",
+			pidff->pid_total_ram);
+
+	if (pidff->pool[PID_POOL_ALIGNMENT].value &&
+			pidff->pool[PID_POOL_ALIGNMENT].value[0] > 0)
+		pidff->alignment = pidff->pool[PID_POOL_ALIGNMENT].value[0];
+	else
+		pidff->alignment = 1;
+	hid_dbg(pidff->hid, "device memory alignment is %d\n",
+			pidff->alignment);
+
+	pidff_report_sizes(pidff);
+
+/*	if (pidff->pool[PID_DEVICE_MANAGED_POOL].value &&
+	    pidff->pool[PID_DEVICE_MANAGED_POOL].value[0] == 0) {*/
+	if (!pidff->pool[PID_DEVICE_MANAGED_POOL].value ||
+	    pidff->pool[PID_DEVICE_MANAGED_POOL].value[0] == 0) {
 		hid_notice(pidff->hid,
-			   "device has unknown autocenter control method\n");
+			   "device does not support device managed pool\n");
+
+		clear_bit(PID_SUPPORTS_DEVICE_MANAGED, &pidff->flags);
 	}
 
-	pidff_erase_pid(pidff,
-			pidff->block_load[PID_EFFECT_BLOCK_INDEX].value[0]);
+	if (pidff->max_effects > PID_EFFECTS_MAX)
+		pidff->max_effects = PID_EFFECTS_MAX;
 
-	return 0;
+	if (pidff->pool[PID_SIMULTANEOUS_MAX].value)
+		hid_dbg(pidff->hid, "max simultaneous effects is %d\n",
+			pidff->pool[PID_SIMULTANEOUS_MAX].value[0]);
 
+	pidff_check_autocenter(pidff, dev);
+
+	if (test_bit(FF_GAIN, dev->ffbit)) {
+		pidff_set(&pidff->device_gain[PID_DEVICE_GAIN_FIELD], 0xffff);
+		hid_hw_request(pidff->hid, pidff->reports[PID_DEVICE_GAIN],
+				     HID_REQ_SET_REPORT);
+	}
 }
 
 /*
@@ -1236,7 +1928,6 @@ int hid_pidff_init(struct hid_device *hi
 						struct hid_input, list);
 	struct input_dev *dev = hidinput->input;
 	struct ff_device *ff;
-	int max_effects;
 	int error;
 
 	hid_dbg(hid, "starting pid init\n");
@@ -1251,6 +1942,10 @@ int hid_pidff_init(struct hid_device *hi
 		return -ENOMEM;
 
 	pidff->hid = hid;
+	pidff->flags = 0xff;	/* Check support later */
+	pidff->recent.id = 0;
+
+	clear_bit(PID_IS_LAZY_INITIALIZED, &pidff->flags);
 
 	pidff_find_reports(hid, HID_OUTPUT_REPORT, pidff);
 	pidff_find_reports(hid, HID_FEATURE_REPORT, pidff);
@@ -1267,41 +1962,25 @@ int hid_pidff_init(struct hid_device *hi
 
 	pidff_reset(pidff);
 
-	if (test_bit(FF_GAIN, dev->ffbit)) {
-		pidff_set(&pidff->device_gain[PID_DEVICE_GAIN_FIELD], 0xffff);
-		hid_hw_request(hid, pidff->reports[PID_DEVICE_GAIN],
-				     HID_REQ_SET_REPORT);
+	/* This one should work with device managed devices */
+	if (pidff->block_load[PID_EFFECT_BLOCK_INDEX].field) {
+		pidff->max_effects =
+			pidff->block_load[PID_EFFECT_BLOCK_INDEX].field->logical_maximum -
+			pidff->block_load[PID_EFFECT_BLOCK_INDEX].field->logical_minimum +
+				1;
+	}
+
+	/* And if it fails, this one should work with driver managed */
+	if (!pidff->max_effects &&
+			pidff->set_effect[PID_EFFECT_BLOCK_INDEX].field) {
+		pidff->max_effects =
+			pidff->set_effect[PID_EFFECT_BLOCK_INDEX].field->logical_maximum -
+			pidff->set_effect[PID_EFFECT_BLOCK_INDEX].field->logical_minimum +
+				1;
 	}
+	hid_dbg(pidff->hid, "device max effects %d\n", pidff->max_effects);
 
-	error = pidff_check_autocenter(pidff, dev);
-	if (error)
-		goto fail;
-
-	max_effects =
-	    pidff->block_load[PID_EFFECT_BLOCK_INDEX].field->logical_maximum -
-	    pidff->block_load[PID_EFFECT_BLOCK_INDEX].field->logical_minimum +
-	    1;
-	hid_dbg(hid, "max effects is %d\n", max_effects);
-
-	if (max_effects > PID_EFFECTS_MAX)
-		max_effects = PID_EFFECTS_MAX;
-
-	if (pidff->pool[PID_SIMULTANEOUS_MAX].value)
-		hid_dbg(hid, "max simultaneous effects is %d\n",
-			pidff->pool[PID_SIMULTANEOUS_MAX].value[0]);
-
-	if (pidff->pool[PID_RAM_POOL_SIZE].value)
-		hid_dbg(hid, "device memory size is %d bytes\n",
-			pidff->pool[PID_RAM_POOL_SIZE].value[0]);
-
-	if (pidff->pool[PID_DEVICE_MANAGED_POOL].value &&
-	    pidff->pool[PID_DEVICE_MANAGED_POOL].value[0] == 0) {
-		hid_notice(hid,
-			   "device does not support device managed pool\n");
-		goto fail;
-	}
-
-	error = input_ff_create(dev, max_effects);
+	error = input_ff_create(dev, pidff->max_effects);
 	if (error)
 		goto fail;
 
@@ -1318,6 +1997,20 @@ int hid_pidff_init(struct hid_device *hi
 	return 0;
 
  fail:
+	pidff_empty_memory(pidff);
 	kfree(pidff);
 	return error;
 }
+
+/*
+ * Remove any allocated memory (for driver managed mode)
+ */
+void hid_pidff_destroy(struct hid_device *hid)
+{
+	struct hid_input *hidinput = list_entry(hid->inputs.next,
+			struct hid_input, list);
+	struct input_dev *dev = hidinput->input;
+	struct pidff_device *pidff = dev->ff->private;
+	if (pidff)
+		pidff_empty_memory(pidff);
+}
